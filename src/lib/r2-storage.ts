/**
 * R2 Storage Abstraction Layer
 * 
 * This module provides utilities for interacting with Cloudflare R2 storage.
 * All uploads/deletes go through the R2 Auth Worker which validates JWT tokens.
 * Public reads go directly to the CDN URL.
 * 
 * @see MIGRATION_PLAN.md for storage schema details
 */

// Environment configuration
const R2_BASE_URL = import.meta.env.VITE_R2_STORAGE_URL || 'https://storage.manzanillo-real-estate.com';
const R2_WORKER_URL = import.meta.env.VITE_R2_WORKER_URL || 'https://r2-auth.habitex.workers.dev';

// ============================================================================
// Types
// ============================================================================

export interface UploadResult {
  success: boolean;
  url: string;
  path: string;
}

export interface UploadProgress {
  loaded: number;
  total: number;
  percentage: number;
}

export type ImageVariant = 'original' | 'thumb' | 'medium';
export type VideoAsset = 'original' | 'thumb' | 'preview';

// ============================================================================
// Path Generators
// ============================================================================

/**
 * Generate path for user profile avatar
 * Avatar is always overwritten (not versioned)
 */
export function getProfileAvatarPath(userId: string): string {
  return `users/${userId}/profile/avatar`;
}

/**
 * Generate path for user profile cover image
 * Cover is always overwritten (not versioned)
 */
export function getProfileCoverPath(userId: string): string {
  return `users/${userId}/profile/cover`;
}

/**
 * Generate path for property image
 * @param seq - Sequence number (1-50), will be zero-padded to 3 digits
 */
export function getPropertyImagePath(userId: string, propertyId: string, seq: number): string {
  const paddedSeq = String(seq).padStart(3, '0');
  return `users/${userId}/properties/${propertyId}/images/${paddedSeq}`;
}

/**
 * Generate path for property video
 * @param seq - Sequence number (1-3), will be zero-padded to 3 digits
 */
export function getPropertyVideoPath(userId: string, propertyId: string, seq: number): string {
  const paddedSeq = String(seq).padStart(3, '0');
  return `users/${userId}/properties/${propertyId}/videos/${paddedSeq}`;
}

/**
 * Generate path for AI job input images
 */
export function getAIJobInputPath(userId: string, jobId: string, seq: number): string {
  const paddedSeq = String(seq).padStart(3, '0');
  return `users/${userId}/ai-jobs/${jobId}/inputs/${paddedSeq}`;
}

/**
 * Generate path for AI-generated images
 */
export function getAIJobGeneratedPath(userId: string, jobId: string, seq: number): string {
  const paddedSeq = String(seq).padStart(3, '0');
  return `users/${userId}/ai-jobs/${jobId}/generated/${paddedSeq}`;
}

/**
 * Generate path for AI job output video
 */
export function getAIJobOutputPath(userId: string, jobId: string): string {
  return `users/${userId}/ai-jobs/${jobId}/output/video`;
}

// ============================================================================
// URL Generators
// ============================================================================

/**
 * Get public CDN URL for a file
 * Variants are auto-generated by the Media Processing Worker
 * 
 * @param path - Base path without extension
 * @param variant - For images: 'thumb' or 'medium'. For videos: 'thumb' or 'preview'
 * @param extension - File extension (defaults to 'jpg' for variants)
 */
export function getPublicUrl(
  path: string, 
  variant?: ImageVariant | VideoAsset,
  extension: string = 'jpg'
): string {
  // If path already has extension, use it
  const hasExtension = /\.[a-zA-Z0-9]+$/.test(path);
  
  if (!variant || variant === 'original') {
    return hasExtension ? `${R2_BASE_URL}/${path}` : `${R2_BASE_URL}/${path}.${extension}`;
  }
  
  // Variant URLs always use jpg for images, gif for preview
  if (variant === 'preview') {
    const basePath = path.replace(/\.[^.]+$/, '');
    return `${R2_BASE_URL}/${basePath}.preview.gif`;
  }
  
  const basePath = hasExtension ? path.replace(/\.[^.]+$/, '') : path;
  return `${R2_BASE_URL}/${basePath}.${variant}.jpg`;
}

/**
 * Get thumbnail URL for an image or video
 */
export function getThumbnailUrl(path: string): string {
  return getPublicUrl(path, 'thumb');
}

/**
 * Get medium-sized image URL
 */
export function getMediumUrl(path: string): string {
  return getPublicUrl(path, 'medium');
}

/**
 * Get GIF preview URL for a video
 */
export function getPreviewUrl(path: string): string {
  return getPublicUrl(path, 'preview');
}

/**
 * Construct full URL from stored sequence number
 * Properties store just sequence numbers like ['001', '002']
 */
export function getPropertyImageUrl(
  userId: string, 
  propertyId: string, 
  seq: string | number,
  variant: ImageVariant = 'original'
): string {
  const paddedSeq = typeof seq === 'number' ? String(seq).padStart(3, '0') : seq;
  const path = `users/${userId}/properties/${propertyId}/images/${paddedSeq}`;
  return getPublicUrl(path, variant);
}

/**
 * Construct full video URL from stored sequence number
 */
export function getPropertyVideoUrl(
  userId: string, 
  propertyId: string, 
  seq: string | number,
  asset: VideoAsset = 'original'
): string {
  const paddedSeq = typeof seq === 'number' ? String(seq).padStart(3, '0') : seq;
  const path = `users/${userId}/properties/${propertyId}/videos/${paddedSeq}`;
  
  if (asset === 'original') {
    return `${R2_BASE_URL}/${path}.mp4`;
  }
  
  return getPublicUrl(path, asset);
}

// ============================================================================
// Upload Operations
// ============================================================================

/**
 * Upload a file to R2 storage
 * Requires valid Supabase JWT token for authentication
 * 
 * @param path - Storage path (without extension, extension derived from file)
 * @param file - File to upload
 * @param token - Supabase access token (session.access_token)
 * @param onProgress - Optional progress callback
 */
export async function uploadFile(
  path: string,
  file: File,
  token: string,
  onProgress?: (progress: UploadProgress) => void
): Promise<UploadResult> {
  // Extract extension from file name
  const ext = file.name.split('.').pop()?.toLowerCase() || 'jpg';
  const fullPath = `${path}.${ext}`;

  // Use XMLHttpRequest for progress tracking if callback provided
  if (onProgress) {
    return uploadWithProgress(fullPath, file, token, onProgress);
  }

  const response = await fetch(`${R2_WORKER_URL}/${fullPath}`, {
    method: 'PUT',
    headers: {
      'Authorization': `Bearer ${token}`,
      'Content-Type': file.type,
    },
    body: file,
  });

  if (!response.ok) {
    const errorText = await response.text().catch(() => 'Upload failed');
    throw new Error(`Upload failed: ${response.status} - ${errorText}`);
  }

  return {
    success: true,
    url: getPublicUrl(fullPath),
    path: fullPath,
  };
}

/**
 * Upload with progress tracking using XMLHttpRequest
 */
function uploadWithProgress(
  fullPath: string,
  file: File,
  token: string,
  onProgress: (progress: UploadProgress) => void
): Promise<UploadResult> {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    
    xhr.upload.addEventListener('progress', (event) => {
      if (event.lengthComputable) {
        onProgress({
          loaded: event.loaded,
          total: event.total,
          percentage: Math.round((event.loaded / event.total) * 100),
        });
      }
    });

    xhr.addEventListener('load', () => {
      if (xhr.status >= 200 && xhr.status < 300) {
        resolve({
          success: true,
          url: getPublicUrl(fullPath),
          path: fullPath,
        });
      } else {
        reject(new Error(`Upload failed: ${xhr.status} - ${xhr.statusText}`));
      }
    });

    xhr.addEventListener('error', () => {
      reject(new Error('Upload failed: Network error'));
    });

    xhr.open('PUT', `${R2_WORKER_URL}/${fullPath}`);
    xhr.setRequestHeader('Authorization', `Bearer ${token}`);
    xhr.setRequestHeader('Content-Type', file.type);
    xhr.send(file);
  });
}

/**
 * Upload profile avatar (512x512 recommended)
 * Overwrites existing avatar
 */
export async function uploadAvatar(
  userId: string,
  file: File,
  token: string
): Promise<UploadResult> {
  const path = getProfileAvatarPath(userId);
  return uploadFile(path, file, token);
}

/**
 * Upload profile cover image (1920x1080 recommended)
 * Overwrites existing cover
 */
export async function uploadCover(
  userId: string,
  file: File,
  token: string
): Promise<UploadResult> {
  const path = getProfileCoverPath(userId);
  return uploadFile(path, file, token);
}

/**
 * Upload property image
 * Returns the sequence number used
 */
export async function uploadPropertyImage(
  userId: string,
  propertyId: string,
  seq: number,
  file: File,
  token: string,
  onProgress?: (progress: UploadProgress) => void
): Promise<UploadResult & { seq: number }> {
  const path = getPropertyImagePath(userId, propertyId, seq);
  const result = await uploadFile(path, file, token, onProgress);
  return { ...result, seq };
}

/**
 * Upload property video
 * Returns the sequence number used
 */
export async function uploadPropertyVideo(
  userId: string,
  propertyId: string,
  seq: number,
  file: File,
  token: string,
  onProgress?: (progress: UploadProgress) => void
): Promise<UploadResult & { seq: number }> {
  const path = getPropertyVideoPath(userId, propertyId, seq);
  const result = await uploadFile(path, file, token, onProgress);
  return { ...result, seq };
}

// ============================================================================
// Delete Operations
// ============================================================================

/**
 * Delete a single file from R2 storage
 * 
 * @param path - Full path to the file (including extension)
 * @param token - Supabase access token
 */
export async function deleteFile(path: string, token: string): Promise<void> {
  const response = await fetch(`${R2_WORKER_URL}/${path}`, {
    method: 'DELETE',
    headers: {
      'Authorization': `Bearer ${token}`,
    },
  });

  if (!response.ok && response.status !== 404) {
    const errorText = await response.text().catch(() => 'Delete failed');
    throw new Error(`Delete failed: ${response.status} - ${errorText}`);
  }
}

/**
 * Delete all files in a folder (prefix)
 * Used for cleaning up property or AI job folders
 * 
 * @param userId - User ID (for path validation)
 * @param folderPath - Path relative to user folder (e.g., 'properties/uuid' or 'ai-jobs/uuid')
 * @param token - Supabase access token
 */
export async function deleteFolder(
  userId: string,
  folderPath: string,
  token: string
): Promise<void> {
  const response = await fetch(`${R2_WORKER_URL}/batch-delete`, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      prefix: `users/${userId}/${folderPath}`,
    }),
  });

  if (!response.ok) {
    const errorText = await response.text().catch(() => 'Folder delete failed');
    throw new Error(`Folder delete failed: ${response.status} - ${errorText}`);
  }
}

/**
 * Delete a property's entire folder including all images and videos
 */
export async function deletePropertyFolder(
  userId: string,
  propertyId: string,
  token: string
): Promise<void> {
  return deleteFolder(userId, `properties/${propertyId}`, token);
}

/**
 * Delete an AI job's entire folder
 */
export async function deleteAIJobFolder(
  userId: string,
  jobId: string,
  token: string
): Promise<void> {
  return deleteFolder(userId, `ai-jobs/${jobId}`, token);
}

// ============================================================================
// Utility Functions
// ============================================================================

/**
 * Check if a file exists by making a HEAD request
 */
export async function fileExists(path: string): Promise<boolean> {
  try {
    const response = await fetch(`${R2_BASE_URL}/${path}`, {
      method: 'HEAD',
    });
    return response.ok;
  } catch {
    return false;
  }
}

/**
 * Get the next available sequence number for property images
 * Checks which sequence numbers are already used
 */
export async function getNextImageSequence(
  userId: string,
  propertyId: string,
  existingSequences: string[] = []
): Promise<number> {
  // Find the first unused sequence from 1-50
  for (let seq = 1; seq <= 50; seq++) {
    const paddedSeq = String(seq).padStart(3, '0');
    if (!existingSequences.includes(paddedSeq)) {
      return seq;
    }
  }
  throw new Error('Maximum image limit (50) reached');
}

/**
 * Get the next available sequence number for property videos
 */
export async function getNextVideoSequence(
  userId: string,
  propertyId: string,
  existingSequences: string[] = []
): Promise<number> {
  // Find the first unused sequence from 1-3
  for (let seq = 1; seq <= 3; seq++) {
    const paddedSeq = String(seq).padStart(3, '0');
    if (!existingSequences.includes(paddedSeq)) {
      return seq;
    }
  }
  throw new Error('Maximum video limit (3) reached');
}

/**
 * Validate file size
 * @param file - File to validate
 * @param maxSizeMB - Maximum size in megabytes
 */
export function validateFileSize(file: File, maxSizeMB: number): boolean {
  return file.size <= maxSizeMB * 1024 * 1024;
}

/**
 * Validate image file type
 */
export function isValidImageType(file: File): boolean {
  const validTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'];
  return validTypes.includes(file.type);
}

/**
 * Validate video file type
 */
export function isValidVideoType(file: File): boolean {
  const validTypes = ['video/mp4', 'video/quicktime', 'video/webm'];
  return validTypes.includes(file.type);
}

/**
 * Storage limits from MIGRATION_PLAN.md
 */
export const STORAGE_LIMITS = {
  MAX_IMAGES_PER_PROPERTY: 75,
  MAX_VIDEOS_PER_PROPERTY: 3,
  MAX_IMAGE_SIZE_MB: 5,
  MAX_VIDEO_SIZE_MB: 50,
  AVATAR_DIMENSIONS: { width: 512, height: 512 },
  COVER_DIMENSIONS: { width: 1920, height: 1080 },
} as const;
